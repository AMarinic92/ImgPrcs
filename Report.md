# Image Recognition: Andrea Abellera and Andrew Marinic
 ## Introduction
<p>	The goal of our project is to create an image recognition program. The objective of the program is to recognize the balls from a variety of image samples, some which contains balls and others containing round objects that are not balls. These known objects can be used to help us refine our search. </p>
	 <p>	The algorithm  will use the uncanny edge detection to reduce our test image to its edges. The number of trials can be modified to help refine the search. A single trial would search the image as a whole, and then each subsequent trial would scan the trial image in smaller slices to help identify smaller balls, multiple balls, and off centre balls. An algorithm was used to calculate the covariance matrix of the image library, derive weights from the library images and from the test image or slice, then use these to find the distance of a test image or slice from a ball. We then perform a second test with the same goal of recognising the balls from the samples, but instead of derving weights, we compare the difference between each individual library image to the test image to see if we have a good match to any of our library images. The stretch goal would be to extend this methodology to track the progress of the maze mosaic virus in a plant cell. Throughout the report it will be mentioned how certain functions were coded with this in mind.</p> 

## Hypothesis
<p> Defining a ball to the computer is important for our test. By definition, a ball is spherical with uniform, consistent rounded edges. Viewed from any perspective, a ball should appear as round in any image. This differentiates it from a flat disc for an instance, which will appear oblique when viewed slightly from the side. A ball may have textures and patterns, but have less noise and detail than a wheel with spokes or an animal with fur.
	Our hypothesis is as follows. If we reduce an image down to its edges with the uncanny edge detection this will allow us to gather the most defining aspects of a ball, while eliminating less important information. Comparison of images that have not been reduced to its edges would leave far too many variables to give fair comparisons, such as noise from background and textures and a huge range of greyscale values which will complicate our assessment of a ball. After reducing a test image or slice to its edges, we will generate a library of images to test it. In our situation a series of functions is used to generate a directory with perfectly circular rings of varying radii.  Every individual test sample will be compared to this generated library as opposed to each other. We want our algorithm to generate balls instead of gathering confirmed balls to prevent the bias caused by hand-picking our library images. For calculating the distance of a test image from a hypothetical ball, we will implement the facial recognition method that was discussed in class ** [reference] **. As we would like to extend this application to the maze mosaic virus we chose to design the algorithm with the ability to scan in smaller slices. The shape in which we scan depends on what we are looking for. Maze mosaic bacilli are oblique and should be scanned as a rectangle. On the other hand, we should scan balls as a square because balls are spherical and should match a square's dimensions. Then, we will calculate the covariance from the library of reference images, and we will use this to test how close an image is to resembling a single ball in the slice (which can be the entire image). We will then test each slice against each individual image in our reference library. Performing these two tests will allow for us to see how much our image varies from our reference library and if it is an acceptable ball(based on the computed distance), and at the same time find which image in the library it is closest to. The reference images are named after the radius of the circle in the image allowing for us to estimate the balls approximate pixel radius. This allows us to extend the application to testing the maze cell for infected organelles vs non infected organelles, as we would need to pass a reference of healthy vs non healthy regions of the cell and compare how different from each of the libraries it is so we can associate the region as healthy or infected. Our ball application is essentially the same with "has a ball" and "does not have a ball" as our replacements for healthy and unhealthy. </p>

## Methodology 
Running the `runTrials.py` *(Andrew)* starts an experiment to test an ascii PMG file. Each of these experiments is organised into a folder where the uncanny edge detection of the test image and folders containing test libraries is held. This helps keep our trials separate and makes iteration over the libraries easy. `runTrials.py` also handles scanning over the test image. 

Using `uncannyEdge`*(Andrea)* detection is essential for this project. The uncanny process requires a Gaussian blur, it is followed by applying a convolution of a kernel which compares adjacent pixels for likeness to determine an edge, as areas of uniform colour tend not to be edges. The edge is further refined by comparing the edge in an appropriate angle, either horizontally, vertically, or with slope 1 or -1. This will help thin the edge, we then finish off the process by suppressing noise which ignores weak pixels. This is allows us to have the most defining aspects of the images for comparison.

In order to determine if an image contains a ball or not we need to determine what is a ball and how is it different from 

One of method of generating our library is by the use of `makeCircle`*(Andrew)* which is a modified version of Dr.Vaughns face making algorithm. It simply draws a circle of the desire colour (either white or black) and then embeds a circle of the opposite colour inside of it to generate a ring. The ring resembles the results of a circle after uncanny edge with less work for the computer. The `overloadLib` *(Andrew)* generates a reasonably sized library of the images with `makeCircle`*(Andrew)* in varying radii and locations. One of the issues that occurred was making a library that represented a what an image with a ball could be while giving a reasonably sized library to compute `calcD`*(Andrea)*. This library represents what a picture of a ball with no noise would be. A ball is a sphere and when projected into a 2 dimensional image we produce a circle no matter what angle the ball is taken at. This is not true for circular objects like a wheel, but is true for all spheres that are not balls like a globe. We will then pick a series of images the provided images to test against our computer generated library. Table 1 lists the justifications of trial images used for tuning the algorithm. We chose to compare images to an independent library instead of each other to try and prevent our library developing bias from selection of test images. This will help us tune the algorithm to before we 



 - choosing a generated library and comparing balls and non balls to it as opposed to choosing images to compare directly to may prevent bias? (YES! Our hypothesis is pretty substantial now, you can refer to it or transfer some wording to the methodology, I'll start outlining the steps for my functions so that you can start including them here)
 - 
 

# Data and Tables
## Table 1 - Tuning selection
| Image Name        	| Type              	| Justifications                                                                                               	|
|-------------------	|-------------------	|--------------------------------------------------------------------------------------------------------------	|
| Tennis-Ball-4.pgm 	| Ball              	| Multiple balls, Furry edges, Noise                                                                           	|
| Baseball-1.pgm    	| Ball              	| Large single ball, Close to centre, Ball has texture                                                         	|
| Rubber-Ball-7.pgm 	| Ball              	| Image is all balls, All balls are the same, All balls have clean edges                                       	|
| Golf-Ball-1.pgm   	| Ball              	| Surrounded y lots of noise, Ball dose not blend into noise                                                   	|
| Basketball-1.pgm  	| Ball              	| Large ball, off centre, texture in ball, noise in image                                                      	|
| Globe.pgm         	| Sphere(not ball)  	| Computer generated image like library, sphere but not a ball, reflection, most like a ball without being one 	|
| Sunflower.pgm     	| Circular symmetry 	| Symmetry is round but edges are not close to round                                                           	|
| CD-ROM.pgm        	| Circular symmetry 	| Perfect circle, Circle in circle, little noise                                                               	|
| Ferret.ogm        	| Circular Symmetry 	| Circular symmetry, noisy symmetry like tennis ball                                                           	|
| Bicycle.pgm       	| Circular Symmetry 	| Multiple circular objects, lots of noise in picture                                                          	|
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTQ4OTUxMjYwLC0xMjA0NjExNTAyLC00MD
I3MjU3ODQsLTE4NTQ4MDg2NzMsMTAwMTI5ODg2MywtMTM5MDE3
MTM4NywtMjAxMDA3MDAyOCwtMTE5Mjc2NzgwLDM2NzAwODkxNi
wxMzcxMTEyODkxLDEwMTM5NjgzMTEsMjc2MzA5ODU1LC00ODM5
ODM4NzYsLTE3MjE0MDc5NTQsMzYwNTA2NTYzLDcyMjUxNzM2OC
wyMTQ5MDg1MDAsMTYyNjQ1NDE5OSwtMTgzNDc2NjkyOCwtMTQ3
MjU0NjQ1M119
-->