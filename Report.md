# Image Recognition: Andrea Abellera and Andrew Marinic
 ## Introduction
<p>	The goal of our project is to create an image recognition program. The objective of the program is to recognize the balls from a variety of image samples, some which contains balls and others containing round objects that are not balls. These known objects can be used to help us refine our search. </p>
	 <p>	The algorithm  will use the uncanny edge detection to reduce our test image to its edges. The number of trials can be modified to help refine the search. A single trial would search the image as a whole, and then each subsequent trial would scan the trial image in smaller slices to help identify smaller balls, multiple balls, and off centre balls. An algorithm was used to calculate the covariance matrix of the image library, derive weights from the library images and from the test image or slice, then use these to find the distance of a test image or slice from a ball. We then perform a second test with the same goal of recognising the balls from the samples, but instead of derving weights, we compare the difference between each individual library image to the test image to see if we have a good match to any of our library images. The stretch goal would be to extend this methodology to track the progress of the maze mosaic virus in a plant cell. Throughout the report it will be mentioned how certain functions were coded with this in mind.</p> 

## Hypothesis
<p> Defining a ball to the computer is important for our test. By definition, a ball is spherical with uniform, consistent rounded edges. Viewed from any perspective, a ball should appear as round in any image. This differentiates it from a flat disc for an instance, which will appear oblique when viewed slightly from the side. A ball may have textures and patterns, but have less noise and detail than a wheel with spokes or an animal with fur.
	Our hypothesis is as follows. If we reduce an image down to its edges with the uncanny edge detection this will allow us to gather the most defining aspects of a ball, while eliminating less important information. Comparison of images that have not been reduced to its edges would leave far too many variables to give fair comparisons, such as noise from background and textures and a huge range of greyscale values which will complicate our assessment of a ball. After reducing a test image or slice to its edges, we will generate a library of images to test it. In our situation a series of functions is used to generate a directory with perfectly circular rings of varying radii.  Every individual test sample will be compared to this generated library as opposed to each other. We want our algorithm to generate balls instead of gathering confirmed balls to prevent the bias caused by hand-picking our library images. For calculating the distance of a test image from a hypothetical ball, we will implement the facial recognition method that was discussed in class ** [reference] **. As we would like to extend this application to the maze mosaic virus we chose to design the algorithm with the ability to scan in smaller slices. The shape in which we scan depends on what we are looking for. Maze mosaic bacilli are oblique and should be scanned as a rectangle. On the other hand, we should scan balls as a square because balls are spherical and should match a square's dimensions. Then, we will calculate the co-variance from the library of reference images, and we will use this to test how close an image is to resembling a single ball in the slice (which can be the entire image). We will then test each slice against each individual image in our reference library. Performing these two tests will allow for us to see how much our image varies from our reference library and if it is an acceptable ball(based on the computed distance), and at the same time find which image in the library it is closest to. The reference images are named after the radius of the circle in the image allowing for us to estimate the balls approximate pixel radius. This allows us to extend the application to testing the maze cell for infected organelles vs non infected organelles, as we would need to pass a reference of healthy vs non healthy regions of the cell and compare how different from each of the libraries it is so we can associate the region as healthy or infected. Our ball application is essentially the same with "has a ball" and "does not have a ball" as our replacements for healthy and unhealthy. </p>

## Methodology 
Running the `runTrials.py` *(Andrew)* starts an experiment to test an ascii PMG file. Each of these experiments is organised into a folder where the uncanny edge detection of the test image and folders containing test libraries is held. This helps keep our trials separate and makes iteration over the libraries easy. `runTrials.py` also handles scanning over the test image. Initially we started our trials by testing the entire image against the eigen matrix of a library with images of equal size. The issue of computing power became rapidly apparent with certain images. This method was abandoned with this logic to justify it; the largest ball in a rectangular image that is retained within said image has a max radius of the smallest dimension (producing the largest square that can be embedded in the rectangle). Instead of our initial trial testing the image as a whole we will immediately begin by scanning the image. This allowed for smaller initial comparisons, reducing strain on hardware and time required for calculations. 

Using `uncannyEdge`*(Andrea)* detection is essential for this project. The uncanny process requires a Gaussian blur, it is followed by applying a convolution of a kernel which compares adjacent pixels for likeness to determine an edge, as areas of uniform colour tend not to be edges. The edge is further refined by comparing the edge in an appropriate angle, either horizontally, vertically, or with slope 1 or -1. This will help thin the edge, we then finish off the process by suppressing noise which ignores weak pixels. This is allows us to have the most defining aspects of the images for comparison.

We implemented two methods to derive the distance of a test image or slice from the generated library image. Our first technique utilizes the difference of the weight of a test image from a library of weights, which is a concept that had been discussed and applied in class. This computes the distance of a test image against a library of images that cumulatively define a specific object.
We will use this function to determine if a slice in an image contains a ball by assessing if it is a close match to any of the library images and does not deviate far from the average ball estimated by the library. The function takes a directory containing the library of images, computes its covariance matrix and derives the weight that each image contributes to an "average-looking" ball. A test image is taken, weighed and compared against each weighed entry, and the smallest value is returned. 

One of method of generating our library is by the use of `makeCircle`*(Andrew)* which is a modified version of Dr.Vaughns face making algorithm. It simply draws a circle of the desire colour (either white or black) and then embeds a circle of the opposite colour inside of it to generate a ring. The ring resembles the results of a circle after uncanny edge with less work for the computer. The `overloadLib` *(Andrew)* generates a reasonably sized library of the images with `makeCircle`*(Andrew)* in varying radii and locations. One of the issues that occurred was making a library that represented a what an image with a ball could be while giving a reasonably sized library to compute `calcD`*(Andrea)*. This library represents what a picture of a ball with no noise would be. A ball is a sphere and when projected into a 2 dimensional image we produce a circle no matter what angle the ball is taken at. This is not true for circular objects like a wheel, but is true for all spheres that are not balls like a globe. We will then pick a series of images the provided images to test against our computer generated library. Table 1 lists the justifications of trial images used for tuning the algorithm. We chose to compare images to an independent library instead of each other to try and prevent our library developing bias from selection of test images. This will help us tune the algorithm to before we start adding to it with balls we have confirmed from test images. 

Calculating the difference between the input image and both the eigen matrix of the library and each image in it is how we are going to gather empirical evidence to prove or disprove our hypothesis. Using the tuning method above we should be able to 

`runTrials.py` also is responsible for scanning our image. The script asks for an input of trials to be run. Each trial after the first treats the test image as a sub-matrix of the whole image and changes its position effectively scanning the test image with a smaller square each time. One issue which can occur during scanning is how large of increments are taken. If a ball is found you may scan the same area counting multiple regions as containing balls when in reality it may be the same ball. If a ball is detected in a region it may prove to be effective to jump a large span in the scan to prevent this. Alternatively it may also be effective to compare d-values (difference of edges) of adjacent slices to see which is closest to our thresholds of what is and is not a ball. 

In order to determine if an image contains a ball or not we need to determine what is a ball and how is it different from other round objects. A series of p

## Table 1 - Tuning selection
| Image Name *[ref]*        	| Type              	| Justifications                                                                                               	|
|-------------------	|-------------------	|--------------------------------------------------------------------------------------------------------------	|
| Tennis-Ball-4.pgm [1] 	| Ball              	| Multiple balls, Furry edges, Noise                                                                           	|
| Baseball-1.pgm [2]   	| Ball              	| Large single ball, Close to centre, Ball has texture                                                         	|
|Soccer-Ball-1.pgm [3]|Ball | Large, noisey inside and outside, takes up majority of image |
| Rubber-Ball-7.pgm [4]	| Ball              	| Image is all balls, All balls are the same, All balls have clean edges                                       	|
| Golf-Ball-1.pgm   [5]	| Ball              	| Surrounded y lots of noise, Ball dose not blend into noise                                                   	|
| Basketball-1.pgm [6] 	| Ball              	| Large ball, off centre, texture in ball, noise in image                                                 	|
| Globe.pgm    [7]     	| Sphere(not ball)  	| Computer generated image like library, sphere but not a ball, reflection, most like a ball without being one 	|
| Sunflower.pgm   [8]	| Circular symmetry 	| Symmetry is round but edges are not close to round                                                           	|
| CD-ROM.pgm      [9]  	| Circular symmetry 	| Perfect circle, Circle in circle, little noise                                                               	|
| Ferret.pgm        [10]	| Circular Symmetry 	| Circular symmetry, noisy symmetry like tennis ball                                                           	|
| Bicycle.pgm    [11]   	| Circular Symmetry 	| Multiple circular objects, lots of noise in picture                                                          	|



Apart from getting the weighted distances, we would want to derive a test image's distance from each individual library image as well. For that, we implemented a `calcD_all` *(Andrea)* function, which gathers all the images in a library directory, and calls `calcD_single` *(Andrea)* to test the test slice against each library image. If one of tests return a passing score of above 80 percent, the function attests that ball is found. If all of the tests fail, the function will attest that there is no ball in the slice. In general, `calcD_single` assesses the percentage of the completion of a circle. Where a pixel in the library image is found, the test image is tested for a pixel in the same region and if it exceeds the cut-off for what would be considered an edge in pixel value, it becomes valid point in the circumference and the test score is increased.

We use a second library generator to aid the processing of calcD_all called find_radii *(Andrea)*. This function gets the approximate locations of circles in an image and generates a library of images to hypothetically match that circle. The function probes across a horizontal strip from the centre edge to the centre or a vertical strip from the top edge to the centre and searches for relatively whiter pixels which could signal the edge of a ball. The function then calls another version of makeCircle *(Andrea)*. Given the dimensions of a test array, the function calculates the centre and for every half degree, plots a white point to form the outline of the circle.

Like the weighed calcD, this method has its advantages and drawbacks. Calculating individual distances is a relatively quick method, and is very efficient if the test images has minimal detail and noise. The algorithm has the ability to bypass some faint background noise and noisy central details. However, some test images may still contain more bright noise which will generate a lot of library image files that consume space. Number of comparisons between test image and library images increase and will take more time. A major drawback of this method that the success of this function is extremely dependent on library circles being plotted very close to the size and position of the round object's edges in the test image. We remediated the function by allowing "zeroed-on" pixels to also test its neighbours. Circles that are considerably off-centre when a slice is taken will prove to be a problem. As only hypothetical, centred circles are drawn, assessing distances on other images may not be accurate and ball recognition may fail. The method worked best with single-test, huge, centred balls that fill the image.
 
# References
1. Star Mark Andrew  (2019),  *Tennis Balls And Rackets*. [https://publicdomainpictures.net/pictures/230000/velka/palline-da-tennis-e-racchetta.jpg](https://publicdomainpictures.net/pictures/230000/velka/palline-da-tennis-e-racchetta.jpg)
2. Siedlecki Piotr (2019), *Baseball Ball*.[https://publicdomainpictures.net/pictures/70000/velka/baseball-ball.jpg](https://publicdomainpictures.net/pictures/70000/velka/baseball-ball.jpg)
3. Haroon Ahmad (2019), *Fidato Soccer Ball*. [https://publicdomainpictures.net/pictures/90000/velka/fidato-soccer-ball.jpg](https://publicdomainpictures.net/pictures/90000/velka/fidato-soccer-ball.jpg)
4. Kratochvil Petr (2019), *Colorful Play Balls*.[https://www.publicdomainpictures.net/pictures/30000/velka/colorful-play-balls.jpg](https://www.publicdomainpictures.net/pictures/30000/velka/colorful-play-balls.jpg)
5. Brennan Paul (2019), *Golf Ball On Putting Green*. [https://publicdomainpictures.net/pictures/130000/velka/golf-ball-on-putting-green.jpg](https://publicdomainpictures.net/pictures/130000/velka/golf-ball-on-putting-green.jpg)
6. Mallette Linnaea (2019), *Basketball In A Sand Box* [https://www.publicdomainpictures.net/pictures/120000/velka/basketball-in-a-sand-box.jpg](https://www.publicdomainpictures.net/pictures/120000/velka/basketball-in-a-sand-box.jpg)
7. Stachowiak Kai (2019), *Glass Globe*. [https://www.publicdomainpictures.net/pictures/150000/velka/glaskugel-weltkugel.jpg](https://www.publicdomainpictures.net/pictures/150000/velka/glaskugel-weltkugel.jpg)
8. Kratochvil Petr (2019), *Sunflower*. [https://www.publicdomainpictures.net/pictures/10000/velka/_MG_3370.jpg](https://www.publicdomainpictures.net/pictures/10000/velka/_MG_3370.jpg)
9. Shemesh Marina (2019), *Colored CD-ROM*. [https://www.publicdomainpictures.net/en/view-image.php?image=220142&picture=colored-cd-rom](https://www.publicdomainpictures.net/en/view-image.php?image=220142&picture=colored-cd-rom)
10. Dokoupil Jiří (2019), *Ferret In A Ball*. [https://www.publicdomainpictures.net/pictures/30000/velka/fretka-v-klubicku.jpg](https://www.publicdomainpictures.net/pictures/30000/velka/fretka-v-klubicku.jpg)
11.  Arnold Karen (2019), *Bicycle*. [https://www.publicdomainpictures.net/pictures/90000/velka/bicycle-1398536732m7w.jpg](https://www.publicdomainpictures.net/pictures/90000/velka/bicycle-1398536732m7w.jpg)
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyNzIzMDExODUsLTY2NTM3MDM0NSwxOT
g3MzM0NjA5LDE1NjY4OTc1Myw4Njk0ODQxMywxMDU0OTI5NjQ3
LDEwMTk5MDI1NzQsMTk4NDMwMDg5MSwtMjY1MjkzNTU0LC0xMj
A0NjExNTAyLC00MDI3MjU3ODQsLTE4NTQ4MDg2NzMsMTAwMTI5
ODg2MywtMTM5MDE3MTM4NywtMjAxMDA3MDAyOCwtMTE5Mjc2Nz
gwLDM2NzAwODkxNiwxMzcxMTEyODkxLDEwMTM5NjgzMTEsMjc2
MzA5ODU1XX0=
-->